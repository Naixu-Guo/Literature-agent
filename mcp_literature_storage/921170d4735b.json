{
  "id": "921170d4735b",
  "source": "/var/folders/05/6f0vjthd471ff1qt42rb7nlw0000gn/T/tmppsi3wy_j.pdf",
  "metadata": {
    "title": "https://arxiv.org/pdf/2107.10764.pdf",
    "source_type": "pdf",
    "path": "/var/folders/05/6f0vjthd471ff1qt42rb7nlw0000gn/T/tmppsi3wy_j.pdf",
    "pages": 10,
    "file_size": 598699
  },
  "chunks": [
    "Nonlinear transformation of complex amplitudes via quantum singular value\ntransformation\nNaixu Guo, 1, \u2217 Kosuke Mitarai, 1, 2, 3,\u2020 and Keisuke Fujii 1, 2, 4,\u2021\n1Graduate School of Engineering Science, Osaka University,\n1-3 Machikaneyama, Toyonaka, Osaka 560-8531, Japan\n2Center for Quantum Information and Quantum Biology, Osaka University, Japan\n3JST PRESTO, Japan\n4Center for Emergent Matter Science, RIKEN, Wako Saitama 351-0198, Japan\n(Dated: May 20, 2024)\nDue to the linearity of quantum operations, it is not straightforward to implement nonlinear\ntransformations on a quantum computer, making some practical tasks like a neural network hard to\nbe achieved. In this work, we define a task called nonlinear transformation of complex amplitudes\nand provide an algorithm to achieve this task. Specifically, we construct a block-encoding of complex\namplitudes from a state preparation unitary. This allows us to transform the complex amplitudes",
    "and provide an algorithm to achieve this task. Specifically, we construct a block-encoding of complex\namplitudes from a state preparation unitary. This allows us to transform the complex amplitudes\nby using quantum singular value transformation. We evaluate the required overhead in terms of\ninput dimension and precision, which reveals that the algorithm depends on the roughly square root\nof input dimension and achieves an exponential speedup on precision compared with previous work.\nWe also discuss its possible applications to quantum machine learning, where complex amplitudes\nencoding classical or quantum data are processed by the proposed method. This paper provides\na promising way to introduce the highly complex nonlinearity of the quantum states, which is\nessentially missing in quantum mechanics.\nI. INTRODUCTION\nQuantum mechanics is fundamentally linear. Quan-\ntum operations are all unitaries in matrix representation,\nand the measurement is the only way in which we can",
    "I. INTRODUCTION\nQuantum mechanics is fundamentally linear. Quan-\ntum operations are all unitaries in matrix representation,\nand the measurement is the only way in which we can\nproduce the nonlinearity. If deterministic nonlinear op-\nerations are allowed, quantum computers can solve NP-\nhard problems in polynomial time [1]. This result implies\nthe difficulty of nonlinear quantum operations. However,\nnonlinearity plays an essential role in applications such\nas nonlinear differential equations and machine learning.\nIt is important to consider how to implement a nonlinear\ntransformation on a quantum computer, even if it can\nonly be applied probabilistically.\nThe key idea for applying probabilistic nonlinear oper-\nations is to use a post-selection, i.e., the desired transfor-\nmation is applied on target subsystems if ancilla qubits\nare measured in a certain state. The Harrow-Hassidim-\nLloyd (HHL) algorithm [2], for example, used this idea to",
    "mation is applied on target subsystems if ancilla qubits\nare measured in a certain state. The Harrow-Hassidim-\nLloyd (HHL) algorithm [2], for example, used this idea to\nprovide an exponential speedup for solving linear systems\nof equations compared with classical computers.\nIn recent years, methods for performing nonlinear op-\nerations have been developed rapidly. Quantum signal\nprocessing [3] is a technique to perform desired nonlinear\nfunctions on eigenvalues of a unitary operator. Quantum\nsingular value transformation (QSVT) [4] is its general-\nization to perform nonlinear functions on singular val-\nues of a matrix encoded in a unitary. Existing quan-\ntum algorithms can be reconstructed in terms of QSVT\n\u2217 naixuguo@gmail.com\n\u2020 mitarai@qc.ee.es.osaka-u.ac.jp\n\u2021 fujii@qc.ee.es.osaka-u.ac.jp\n[4, 5], which unifies the disparate problems like Hamilto-\nnian simulation [3, 6\u20138], linear equation solving [2, 9] and\namplitude amplification techniques [10\u201312], implying the",
    "[4, 5], which unifies the disparate problems like Hamilto-\nnian simulation [3, 6\u20138], linear equation solving [2, 9] and\namplitude amplification techniques [10\u201312], implying the\nimportance of developing tools to introduce nonlinearity\non quantum computers.\nHere, we consider how to perform nonlinear transfor-\nmations on the state amplitudes directly, rather than\nthe nonlinear transformation of matrices described in the\nprevious work [4]. We call this task nonlinear transfor-\nmation of complex amplitudes (NTCA), which is defined\nas follows. Assume we have access to a state preparation\noracle\nU : |0\u27e9 \u2192\nNX\nk=1\nck |k\u27e9, (1)\nwhich encodes a complex vector \u20d7 c= {c1, \u00b7\u00b7\u00b7 , cN }. We\nalso assume having access to its adjoint and their con-\ntrolled versions. For given nonlinear functions P, Q:\nR \u2192 C, NTCA is a task to prepare a quantum circuit\nsuch that its output state is\n1\u221ac\nNX\nk=1\n(P(xk) + Q(yk)) |k\u27e9, (2)\nwhere xk + iyk = ck and c is a normalization factor.",
    "R \u2192 C, NTCA is a task to prepare a quantum circuit\nsuch that its output state is\n1\u221ac\nNX\nk=1\n(P(xk) + Q(yk)) |k\u27e9, (2)\nwhere xk + iyk = ck and c is a normalization factor.\nIn this work, we provide an algorithm for NTCA based\non QSVT. To achieve this, we develop a method called\nblock-encoding of amplitudes , where a unitary operator\nconstructed from the state preparation oracle encodes a\nHermitian matrix, whose singular values are the real or\nimaginary parts of amplitudes, into its subspace. We\nshow that if functions P and Q can be approximated by\nd-degree polynomials P\u2032 and Q\u2032, NTCA can be imple-\narXiv:2107.10764v2  [quant-ph]  17 May 20242\nmented using controlled-U and controlled-U\u2020\nO\n\uf8eb\n\uf8edd\nvuutN/\nNX\nk=1\n|P\u2032(xk) + Q\u2032(yk)|2\n\uf8f6\n\uf8f8\ntimes in expectation. We also provide a discussion about\nhow to exploit this algorithm for quantum machine learn-\ning. More specifically, we consider how to perform a\nneural network on the quantum computer and discuss its",
    "how to exploit this algorithm for quantum machine learn-\ning. More specifically, we consider how to perform a\nneural network on the quantum computer and discuss its\npossible applications. This work opens up a way to imple-\nment nonlinear operations on a quantum computer and\nmay contribute to the field of quantum machine learning.\nThis paper is organized as follows. We define the task\nNTCA and summarize existing important subroutines\nin Section II. In Section III A, we introduce the block-\nencoding of amplitudes . Combining this method with\nQSVT, we construct an algorithm to perform NTCA in\nSection III B. In Section IV, we provide the application of\nthis algorithm and show that NTCA provides us a way to\nperform the neural network task directly on a quantum\ncomputer.\nII. PRELIMINARY\nIn this section, we first define a task called NTCA\nand summarize some subroutines from existing works.\nThroughout this paper, N denotes the dimension of data,",
    "computer.\nII. PRELIMINARY\nIn this section, we first define a task called NTCA\nand summarize some subroutines from existing works.\nThroughout this paper, N denotes the dimension of data,\nn = \u2308log2(N)\u2309, and Is denotes the identity operator for\ns qubits. A quantum state |\u03c8\u27e9 represented in the form\n|\u03c8\u27e9 = ca |a\u27e9+ \u00b7\u00b7\u00b7 means that we focus on the term ca |a\u27e9\nand the residual term is orthogonal to the first term.\nFirst, we formally define NTCA as follows:\nDefinition 1 (Nonlinear transformation of complex am-\nplitudes (NTCA)) . Assume we have access to a state\npreparation oracle U such that U |0\u27e9 = PN\nk=1 ck |k\u27e9,\nwhere ck = xk + iyk and xk, yk are real numbers. We\nalso assume having access to its adjoint and their con-\ntrolled versions. For nonlinear functions P, Q: R \u2192 C\nbounded on the interval [\u22121, 1], output a quantum state\n1\u221a\nc\u2032\nPN\nk=1 bk |k\u27e9 such that it is an \u03b5-approximation to the\n1\u221ac\nPN\nk=1 (P(xk) + Q(yk)) |k\u27e9. Here, c, c\u2032 are the normal-",
    "bounded on the interval [\u22121, 1], output a quantum state\n1\u221a\nc\u2032\nPN\nk=1 bk |k\u27e9 such that it is an \u03b5-approximation to the\n1\u221ac\nPN\nk=1 (P(xk) + Q(yk)) |k\u27e9. Here, c, c\u2032 are the normal-\nization coefficients, and \u03b5-approximation means that, for\nall k and xk, yk \u2208 [\u22121, 1],\n|bk \u2212 P(xk) \u2212 Q(yk)| \u2264\u03b5\nN . (3)\nTo achieve NTCA, we utilize QSVT, which is a tech-\nnique to apply nonlinear functions on singular values of\na matrix. It exploits the so-called block-encoding of a\ntarget matrix defined as follows.\nDefinition 2 (Block-encoding [8, 13]) . Suppose that A\nis an n-qubit operator, \u03b1, \u03b5\u2208 R+ and a \u2208 N. Then we\nsay that the (a + n)-qubit unitary U is an (\u03b1, a, \u03b5)-block-\nencoding of A if\n\u2225A \u2212 \u03b1(\u27e80|\u2297a \u2297 In)U(|0\u27e9\u2297a \u2297 In)\u2225 \u2264\u03b5. (4)\nUsing the block-encoding, QSVT can implement P(A)\nof a Hermitian matrix A for any polynomial P. More\nformally, we can achieve the following.\nLemma 3 (Polynomial eigenvalue transformation of ar-\nbitrary parity [4, Theorem 56]) . Suppose that U is an",
    "of a Hermitian matrix A for any polynomial P. More\nformally, we can achieve the following.\nLemma 3 (Polynomial eigenvalue transformation of ar-\nbitrary parity [4, Theorem 56]) . Suppose that U is an\n(\u03b1, a, \u03b5)-block-encoding of a Hermitian matrix A. If \u03b4 \u2265 0\nand P : R \u2192 C is a d-degree polynomial satisfying that\nfor all x \u2208 [\u22121, 1] : |P(x)| \u22641\n4, (5)\nthen there is a quantum circuit \u02dcU, which is an (1, a+\n3, 4d\np\n\u03b5/\u03b1+N\u03b4 )-block-encoding of P(A/\u03b1), and consists\nof d applications of U and U\u2020 gates, a single application\nof controlled-U and O(ad) other one- and two-qubit gates.\nMoreover, we can compute a description of such a circuit\nwith a classical computer in time O(poly(d, log(1/\u03b4))).\nWe note that this theorem is not exactly Theorem 56\nof Ref. [4] but a slightly generalized version which is\nmentioned in Ref. [4]. The original theorem is a similar\nclaim for real polynomial P\u211c : R \u2192 R requiring two\nancilla qubits instead of three in the above theorem.\nIII. RESULT",
    "mentioned in Ref. [4]. The original theorem is a similar\nclaim for real polynomial P\u211c : R \u2192 R requiring two\nancilla qubits instead of three in the above theorem.\nIII. RESULT\nA. Block-encoding of amplitudes\nIn this subsection, we describe a method that we call\nblock-encoding of amplitudes . Using the state prepara-\ntion oracle U as Definition 1, we construct (1, 1, 0)-block-\nencodings \u02dcG and \u02dcG\u2032 of (2n+1)-qubit Hermitian matrices,\nwhose eigenvalues include respectively the real and imag-\ninary part of amplitudes, i.e.,\n(\u27e80| \u2297 I2n+1) \u02dcG(|0\u27e9 \u2297 I2n+1) =\nNX\nk=1\nxk|\u03c6k\u27e9\u27e8\u03c6k| + \u00b7\u00b7\u00b7 ,\n(6)\n(\u27e80| \u2297 I2n+1) \u02dcG\u2032(|0\u27e9 \u2297 I2n+1) =\nNX\nk=1\nyk|\u03c6\u2032\nk\u27e9\u27e8\u03c6\u2032\nk| + \u00b7\u00b7\u00b7 ,\n(7)\nwhere |\u03c6k\u27e9 and |\u03c6\u2032\nk\u27e9 are mutually orthogonal (2 n + 1)-\nqubit states. Concrete forms of |\u03c6k\u27e9 and |\u03c6\u2032\nk\u27e9 will be\ndescribed later. The result is summarized as the following\ntheorem.\nTheorem 4 (Block-encoding of real part amplitudes) .\nGiven a state preparation oracle U as Definition 1, we\ncan construct a unitary \u02dcG and \u02dcG\u2032 which satisfy Eq. (6)",
    "theorem.\nTheorem 4 (Block-encoding of real part amplitudes) .\nGiven a state preparation oracle U as Definition 1, we\ncan construct a unitary \u02dcG and \u02dcG\u2032 which satisfy Eq. (6)\nand (7) respectively by using controlled- U, controlled-U\u2020\nfour times, and O(n) one- and two-qubit gates.\nProof. The construction is partly based on the previous\nwork [14]. First, we construct a unitary whose eigenval-\nues encode the information of xk. Let W be a sequence3\nFIG. 1. Definition of operation W in Theorem 4\nFIG. 2. Definition of operation G in Theorem 4\nof unitary operations as shown in Fig. 1. Note that,\nW |k\u27e9ad |0\u27e9da,B = |k\u27e9\n2 ad\n\u0012\u0000 NX\nj=1\ncj |j\u27e9 + |k\u27e9\n\u0001\nda|0\u27e9B\n+\n\u0000 NX\nj=1\ncj |j\u27e9 \u2212 |k\u27e9\n\u0001\nda|1\u27e9B\n\u0013\n. (8)\nSee Appendix A 1 for details. LetS0 := In+1\u22122|0\u27e9\u27e80|da,B\nbe a conditional phase-shift gate on the data qubits and\nancilla qubit B, and ZB be the Z gate acting on the\nancilla qubit B. With these operations, we define\nG := W S0W\u2020ZB, (9)\nwhich is shown in Fig. 2. For k \u2208 {1, . . . , N}, we define",
    "ancilla qubit B, and ZB be the Z gate acting on the\nancilla qubit B. With these operations, we define\nG := W S0W\u2020ZB, (9)\nwhich is shown in Fig. 2. For k \u2208 {1, . . . , N}, we define\nthe following normalized states\n|\u03a8k0\u27e9da,B := 1\n2\u03b1k\n\u0012X\nj\ncj |j\u27e9 + |k\u27e9\n\u0013\nda\n|0\u27e9B (10)\n|\u03a8k1\u27e9da,B := 1\n2\u03b2k\n\u0012X\nj\ncj |j\u27e9 \u2212 |k\u27e9\n\u0013\nda\n|1\u27e9B , (11)\nwhere \u03b1k =\nq\n1\n2 (1 + xk), \u03b2k =\nq\n1\n2 (1 \u2212 xk). As shown\nin Appendix A 2, eigenvectors of G are\n|k\u27e9ad |\u03a8k\u00b1\u27e9da,B := 1\u221a\n2 |k\u27e9ad (|\u03a8k0\u27e9 \u00b1 |\u03a8k1\u27e9)da,B , (12)\nFIG. 3. Definition of operation \u02dcG in Theorem 4\nwith the corresponding eigenvalues \u2212xk \u00b1i\np\n1 \u2212 x2\nk. We\nneglect other eigenstates of G since we are only inter-\nested in the subspace which encodes amplitudes. How-\never, since our target is to achieve an operator as Eq. (6),\nwe need to remove the imaginary part of eigenvalues.\nWe achieve this by the circuit in Fig. 3 where we use\ncontrolled versions of G and G\u2020. The idea is that the\nimaginary part of eigenvalues can be canceled by imple-\nmenting 1",
    "We achieve this by the circuit in Fig. 3 where we use\ncontrolled versions of G and G\u2020. The idea is that the\nimaginary part of eigenvalues can be canceled by imple-\nmenting 1\n2 (G + G\u2020). Define \u02dcG as shown in Fig. 3. We\nthen have\n(\u27e80| \u2297 I2n+1) \u02dcG (|0\u27e9 \u2297 I2n+1) = \u22121\n2(G + G\u2020). (13)\nTherefore, \u02dcG is a (1 , 1, 0)-block-encoding of Hermitian\nmatrix \u22121\n2 (G + G\u2020). Eigenvalues of \u22121\n2 (G + G\u2020) are\n{xk}N\nk=1. To construct \u02dcG, we need to use controlled- U,\ncontrolled-U\u2020 four times, and O(n) one- and two-qubit\ngates. Details of gate count are provided in Appendix\nA 3.\n\u02dcG\u2032 can be constructed by the same procedure except\nthat we add an S gate on the ancilla qubit B in W as in\nFig. 1.\nB. Nonlinear transformation of complex\namplitudes\nIn this subsection, we provide an algorithm to imple-\nment NTCA. The idea is to apply Lemma 3 to the block-\nencodings obtained in Theorem 4 to implement desired\nfunctions. We assume the existence of polynomial ap-",
    "ment NTCA. The idea is to apply Lemma 3 to the block-\nencodings obtained in Theorem 4 to implement desired\nfunctions. We assume the existence of polynomial ap-\nproximations of functions P and Q to utilize Theorem 3.\nNote that in principle, any continuous real-valued func-\ntion defined on the interval [ \u22121, 1] can be approximated\nby a polynomial function with arbitrary precision by the\nWeierstrass approximation theorem [15].\nOur quantum algorithm for NTCA is the following.\nTheorem 5 (Nonlinear transformation of complex am-\nplitudes). If functions P and Q in Definition 1 can be\napproximated by dp- and dq-degree polynomials P\u2032 and\nQ\u2032 such that |P\u2032(x) \u2212P(x)|, |Q\u2032(x) \u2212Q(x)| \u2264\u03b5/(4N) for\nall x \u2208 [\u22121, 1], the following holds. Let d := max{dp, dq}\nand \u03b3 := max\nx\u2208[\u22121,1]\n{|P(x)|, |Q(x)|}, then NTCA in Defini-\ntion 1 can be achieved by using controlled- U, controlled-\nU\u2020\nO\n\uf8eb\n\uf8edd\u03b3\nvuutN/\nNX\nk=1\n|P\u2032(xk) + Q\u2032(yk)|2\n\uf8f6\n\uf8f8\ntimes, and\nO\n\uf8eb\n\uf8ednd\u03b3\nvuutN/\nNX\nk=1\n|P\u2032(xk) + Q\u2032(yk)|2\n\uf8f6\n\uf8f8",
    "tion 1 can be achieved by using controlled- U, controlled-\nU\u2020\nO\n\uf8eb\n\uf8edd\u03b3\nvuutN/\nNX\nk=1\n|P\u2032(xk) + Q\u2032(yk)|2\n\uf8f6\n\uf8f8\ntimes, and\nO\n\uf8eb\n\uf8ednd\u03b3\nvuutN/\nNX\nk=1\n|P\u2032(xk) + Q\u2032(yk)|2\n\uf8f6\n\uf8f8\none- and two-qubit gates in expectation.4\nProof overview. We implement P\u2032(x) and Q\u2032(y) sep-\narately by applying Lemma 3 to the block-encodings\nobtained in Theorem 4. This process provides us two\nunitaries P and Q which block-encodes matrices whose\neigenvalues are P\u2032(xk)/(4\u03b3) and Q\u2032(yk)/(4\u03b3), respec-\ntively. The coefficient of 4 \u03b3 is necessary to make the\nfunctions implementable with Lemma 3. Noting that the\neigenstates of the above two unitaries can be prepared by\napplying W operation in Fig. 2 to a computational basis,\nwe then apply P and Q to uniform superpositions of N\neigenstates corresponding to eigenvaluesP\u2032(xk)/(4\u03b3) and\nQ\u2032(yk)/(4\u03b3). The concrete algorithm is provided below.\nProof. First, note that P\u2032(x)/(4\u03b3) satisfies\n|P\u2032(x)/(4\u03b3)| \u22641/4 therefore compatible with Lemma 3.",
    "Q\u2032(yk)/(4\u03b3). The concrete algorithm is provided below.\nProof. First, note that P\u2032(x)/(4\u03b3) satisfies\n|P\u2032(x)/(4\u03b3)| \u22641/4 therefore compatible with Lemma 3.\nBy using \u02dcG in Theorem 4 as an input to Lemma 3 and\nsetting \u03b4 = \u03b5/(16\u03b3N ) in Lemma 3, we can construct\nthe unitary P as a (1 , 4, \u03b5/(16\u03b3))-block-encoding of\nmatrix P\u2032 \u0000\n\u22121\n2 (G + G\u2020)\n\u0001\n/(4\u03b3) where G is the unitary\ndefined by Eq. (9). Details of error analysis are provided\nin Appendix B. With a similar procedure, we can\nconstruct Q as a (1, 4, \u03b5/(16\u03b3))-block-encoding of matrix\nQ\u2032(\u22121\n2 (G\u2032 + G\n\u2032\u2020))/(4\u03b3).\nWe can extract P\u2032(xk) and Q\u2032(yk) to the ampli-\ntudes by injecting eigenstates of P\u2032 \u0000\n\u22121\n2 (G + G\u2020)\n\u0001\nand\nQ\u2032(\u22121\n2 (G\u2032 + G\n\u2032\u2020)) to P and Q respectively. We claim\nthat W |k\u27e9ad |0\u27e9da,B and W\u2032 |k\u27e9ad |0\u27e9da,B is an eigenstate\nof P and Q, respectively. This is because the two\nstates |k\u27e9ad |\u03a8k\u00b1\u27e9da,B in Eq. (12) are the eigenstates of\n\u22121\n2 (G+ G\u2020) with the (degenerate) eigenvalue xk. There-\nfore, any linear combinations of |\u03a8k\u00b1\u27e9da,B, or equiva-",
    "states |k\u27e9ad |\u03a8k\u00b1\u27e9da,B in Eq. (12) are the eigenstates of\n\u22121\n2 (G+ G\u2020) with the (degenerate) eigenvalue xk. There-\nfore, any linear combinations of |\u03a8k\u00b1\u27e9da,B, or equiva-\nlently those of |\u03a8k0\u27e9da,B and |\u03a8k1\u27e9da,B, are eigenvec-\ntors with eigenvalues xk. From Eq. (8), we see that\nW |k\u27e9ad |0\u27e9da,B is a linear combination of |\u03a8k0\u27e9da,B and\n|\u03a8k1\u27e9da,B and hence an eigenvector with the eigenvalue\nxk. Therefore, we have,\nP\nh\n|0\u27e9\u22974\n\u0010\nW |k\u27e9ad |0\u27e9da,B\n\u0011i\n= P\u2032(xk)\n4\u03b3\nh\n|0\u27e9\u22974\n\u0010\nW |k\u27e9ad |0\u27e9da,B\n\u0011i\n+ \u00b7\u00b7\u00b7 ,\n(14)\nQ\nh\n|0\u27e9\u22974\n\u0010\nW\u2032 |k\u27e9ad |0\u27e9da,B\n\u0011i\n= Q\u2032(yk)\n4\u03b3\nh\n|0\u27e9\u22974\n\u0010\nW |k\u27e9ad |0\u27e9da,B\n\u0011i\n+ \u00b7\u00b7\u00b7 .\n(15)\nBy injecting the uniform superposition of the eigenstates,\ni.e., 1\u221a\nN\nPN\nk=1 |0\u27e9\u22974\n\u0010\nW |k\u27e9ad |0\u27e9da,B\n\u0011\nto P, we can get\n1\n4\u03b3\n\u221a\nN\nNX\nk=1\nP\u2032(xk) |0\u27e9\u22974\n\u0010\nW |k\u27e9ad |0\u27e9da,B\n\u0011\n, (16)\nwhich has transformed amplitudes. We can do likewise\nto extract Q\u2032(yk).\nTo achieve NTCA of Definition 1, we have to take a\nlinear combination of P\u2032(xk) and Q\u2032(yk). This can be\nFIG. 4. Quantum circuit for the nonlinear transformation of",
    "to extract Q\u2032(yk).\nTo achieve NTCA of Definition 1, we have to take a\nlinear combination of P\u2032(xk) and Q\u2032(yk). This can be\nFIG. 4. Quantum circuit for the nonlinear transformation of\npart of complex amplitudes\nperformed by the circuit in Fig. 4. The state before the\napplication of controlled-P gate in Fig. 4 is,\n1\u221a\n2N\nNX\nk=1\nh\n|0\u27e9|0\u27e9\u22974\n\u0010\nW |k\u27e9ad |0\u27e9da,B\n\u0011\n+ |1\u27e9|0\u27e9\u22974\n\u0010\nW\u2032 |k\u27e9ad |0\u27e9da,B\n\u0011i\n.\n(17)\nApplying controlled- P and controlled- Q to this state\nleads to the following state:\n1\n4\u03b3\n\u221a\n2N\nNX\nk=1\nh\nP\u2032(xk) |0\u27e9|0\u27e9\u22974\n\u0010\nW |k\u27e9ad |0\u27e9da,B\n\u0011\n+Q\u2032(yk) |1\u27e9|0\u27e9\u22974\n\u0010\nW\u2032 |k\u27e9ad |0\u27e9da,B\n\u0011i\n+ \u00b7\u00b7\u00b7 .\n(18)\nThen, we apply controlled- W\u2020, controlled- W\u2032\u2020 to un-\ncompute the data and B qubits. Finally, applying the\nHadamard gate to the first qubit as in Fig. 4 provides us\nthe desired state,\n1\n8\u03b3\n\u221a\nN\nNX\nk=1\n(P\u2032(xk) + Q\u2032(yk)) |0\u27e9\u22975 |k\u27e9ad |0\u27e9da,B + \u00b7\u00b7\u00b7 ,\n(19)\nwhich contains the target state neglecting the data andB\nqubits. It is obvious that we can implement NTCA if we",
    "the desired state,\n1\n8\u03b3\n\u221a\nN\nNX\nk=1\n(P\u2032(xk) + Q\u2032(yk)) |0\u27e9\u22975 |k\u27e9ad |0\u27e9da,B + \u00b7\u00b7\u00b7 ,\n(19)\nwhich contains the target state neglecting the data andB\nqubits. It is obvious that we can implement NTCA if we\nmeasure the first five qubits and the outcome is |0\u27e9\u22975.\nThe probability of this event is 1\n64\u03b32N\nP\nk |P\u2032(xk)2 +\nQ\u2032(yk)2|.\nWe can use amplitude amplification [16] to boost this\nprobability quadratically. It allows us to achieve the\nNTCA with\nO\n \n\u03b3\ns\nNPN\nk=1 |P\u2032(xk) + Q\u2032(yk)|2\n!\nuse of the circuit in Fig. 4 in expectation. Each of\ncontrolled-P and controlled-Q operations is constructed\nwith O(d) controlled-U and controlled-U\u2020 operations and\nO(nd) elementary gates. Therefore, in total, we use\ncontrolled-U and controlled-U\u2020\nO\n \nd\u03b3\ns\nNPN\nk=1 |P\u2032(xk) + Q\u2032(yk)|2\n!5\ntimes, and\nO\n \nnd\u03b3\ns\nNPN\nk=1 |P\u2032(xk) + Q\u2032(yk)|2\n!\none- and two-qubit gates in expectation to achieve\nNTCA.\nNotice that there is a natural generalization of Theo-\nrem 5. For N1 \u2264 N, we can output the state\n1\n8\u03b3\u221aN1\nN1X\nk=1",
    "NPN\nk=1 |P\u2032(xk) + Q\u2032(yk)|2\n!\none- and two-qubit gates in expectation to achieve\nNTCA.\nNotice that there is a natural generalization of Theo-\nrem 5. For N1 \u2264 N, we can output the state\n1\n8\u03b3\u221aN1\nN1X\nk=1\n(P\u2032(xk) + Q\u2032(yk)) |0\u27e9\u22975 |k\u27e9 + \u00b7\u00b7\u00b7 , (20)\nby slightly modifying the circuit in Fig. 4 so that the\nstate just before the controlled-P operation is the follow-\ning state,\n1\u221a2N1\nN1X\nk=1\nh\n|0\u27e9|0\u27e9\u22974\n\u0010\nW |k\u27e9ad |0\u27e9da,B\n\u0011\n+ |1\u27e9|0\u27e9\u22974\n\u0010\nW\u2032 |k\u27e9ad |0\u27e9da,B\n\u0011i\n,\n(21)\ninstead of the uniform superposition ofN eigenstates pre-\npared in Eq. (17). If we are only interested in performing\nnonlinear transformations to a part of the amplitudes, we\ncan benefit from this generalization.\nAnother remark is that, if we consider the case with\nreal function P : R \u2192 R acting on the real part of ampli-\ntudes, we can reduce the total number of ancilla qubits\nfrom five to three. This is because we can construct P\nwith only two ancilla qubits in this case as mentioned ear-",
    "tudes, we can reduce the total number of ancilla qubits\nfrom five to three. This is because we can construct P\nwith only two ancilla qubits in this case as mentioned ear-\nlier in Sec. II, and the sum between functions P and Q\nbecomes unnecessary. Therefore, with a continuous real-\nvalued function P and its polynomial approximation P\u2032,\nfor N1 \u2264 N we can prepare the following state,\n1\n2\u03b3\u221aN1\nN1X\nk=1\nP\u2032(xk) |0\u27e9\u22973 |k\u27e9ad |0\u27e9\u2297n+1\nda,B + \u00b7\u00b7\u00b7 , (22)\nonly requiring three ancilla qubits.\nC. Comparison with previous work\nOur work is inspired by the previous work [14], based\non which we focus on how to apply nonlinear functions on\namplitudes of a quantum state on the quantum computer.\nRef. [14] also considered performing nonlinear transfor-\nmation of amplitudes. Let us compare the present work\nwith Ref. [14] in the case where we wish to implement\nonly P : R \u2192 R acting on real parts of amplitudes. Their\nalgorithm works by first performing quantum phase esti-",
    "with Ref. [14] in the case where we wish to implement\nonly P : R \u2192 R acting on real parts of amplitudes. Their\nalgorithm works by first performing quantum phase esti-\nmation [17] of the unitary G defined in Eq. (9) to encode\nxk (and yk) into bitstrings as PN\nk=1 |k\u27e9| \u00afxk\u27e9, where \u00afxk\nis a binary representation of xk. Then, using an ancilla\nqubit and arithmetical operations, it prepares a state in\nthe form of\nNX\nk=1\n|k\u27e9| \u00afxk\u27e9\n\u0010\nP(xk) |0\u27e9 +\np\n1 \u2212 P(xk)2 |1\u27e9\n\u0011\n,\nfrom which we can obtain the desired state if we mea-\nsure the ancilla qubit in |0\u27e9 state. If this algorithm is ap-\nplied to the same setting as Definition 1, it would require\nO(N/\u03b5) uses of the controlled- G and hence the same\namount of controlled-U in the phase estimation step. In\ntotal, it would require\n\u02dcO\n\uf8eb\n\uf8edN/\u03b5\nvuutN/\nNX\nk=1\n|P(xk)|2\n\uf8f6\n\uf8f8\nuses of controlled-U. In contrast, the algorithm presented\nin Theorem 5 uses\nO\n\uf8eb\n\uf8edd\u03b3\nvuutN/\nNX\nk=1\n|P\u2032(xk) + Q\u2032(yk)|2\n\uf8f6\n\uf8f8\nof controlled-U, where d implicitly depends on the pre-",
    "NX\nk=1\n|P(xk)|2\n\uf8f6\n\uf8f8\nuses of controlled-U. In contrast, the algorithm presented\nin Theorem 5 uses\nO\n\uf8eb\n\uf8edd\u03b3\nvuutN/\nNX\nk=1\n|P\u2032(xk) + Q\u2032(yk)|2\n\uf8f6\n\uf8f8\nof controlled-U, where d implicitly depends on the pre-\ncision requirement N/\u03b5. In many cases, d can be taken\nas d = O(log(N/\u03b5)) [4], and thus we achieve exponential\nspeedup in terms of N and \u03b5. This improvement is im-\nportant when we consider the running time of possible\napplications like a quantum neural network, as described\nin the next section. We also need fewer ancilla qubits for\nNTCA. While our quantum algorithm needsO(n) ancilla\nqubits, Ref. [14] needs O(n + log(N/\u03b5)).\nIV. APPLICATION TO QUANTUM MACHINE\nLEARNING\nLet us finally discuss possible applications of NTCA for\nmachine learning tasks. A straightforward application of\nthe NTCA is to implement the neural network by using\nthe complex amplitudes as its nodes as follows. For a\n(classical) data vector \u20d7 x= {x1, x2, \u00b7\u00b7\u00b7 , xN } \u2208RN , let",
    "the NTCA is to implement the neural network by using\nthe complex amplitudes as its nodes as follows. For a\n(classical) data vector \u20d7 x= {x1, x2, \u00b7\u00b7\u00b7 , xN } \u2208RN , let\nus assume that we have a data-encoding unitary U\u20d7 xsuch\nthat,\nU\u20d7 x: |0\u27e9 \u2192\nNX\nk=1\nxk |k\u27e9. (23)\nThis is the so-called amplitude encoding of classical data\n[18]. U\u20d7 xcan be constructed via the use of quantum ran-\ndom access memory (QRAM) [19] with the data struc-\nture mentioned in Ref. [20]. Using U\u20d7 xand an orthogonal\nmatrix O = P\nj,k ojk|j\u27e9\u27e8k|, we can prepare,\nNX\nk=1\nP\n\uf8eb\n\uf8ed\nNX\nj=1\nokjxj\n\uf8f6\n\uf8f8|k\u27e9, (24)6\nwhose amplitudes correspond to the outputs of a single-\nlayer neural network with an activation function P and\nan orthogonal weight matrix, by using OUdata as U in\nTheorem 5. Note that the normalization factor is omit-\nted to simplify the notation. We will do so henceforth\nif the normalization factor is not needed explicitly for\ndiscussions. We also analyze the concrete implementa-",
    "ted to simplify the notation. We will do so henceforth\nif the normalization factor is not needed explicitly for\ndiscussions. We also analyze the concrete implementa-\ntion of a famous activation function P(x) = tanh( x) in\nAppendix C.\nWe can straightforwardly generalize them for a com-\nplex input vector |\u03c8\u27e9 = PN\nk=1 \u03c8k |k\u27e9. Let U\u03c8 |0\u27e9 := |\u03c8\u27e9.\nOur NTCA algorithm can prepare a state in the form of,\nNX\nk=1\nF\n\uf8eb\n\uf8ed\nNX\nj=1\nvkj\u03c8j\n\uf8f6\n\uf8f8|k\u27e9 (25)\nF : C \u2192 C is an activation function in the form of\nF(\u03c8) = P(Re(\u03c8)) + Q(Im(\u03c8)), and vkj are elements of\na (tranable) unitary V = P\nkj vkj |k\u27e9\u27e8j|, by using V U\u03c8\nas U in Theorem 5. The amplitudes of this state can be\nregarded as the outputs of a single-layer neural network\nwith input datum {\u03c8k}.\nWhile U\u03c8 naturally includes the amplitude encoding\nunitary defined in Eq. (23), it is notable that U\u03c8 can\nbe any encoding of a classical data \u20d7 xto quantum state\n|\u03c8(\u20d7 x)\u27e9 such as the ones proposed in quantum machine",
    "unitary defined in Eq. (23), it is notable that U\u03c8 can\nbe any encoding of a classical data \u20d7 xto quantum state\n|\u03c8(\u20d7 x)\u27e9 such as the ones proposed in quantum machine\nlearning literatures [21\u201326]. Moreover, we believe that a\nmore important situation for NTCA is when the input\nstate |\u03c8\u27e9 has intrinsic quantumness. For example, we\nmight be able to learn properties of a certain family of\nHamiltonians H by directly feeding a time-evolved state\neiHt |0\u27e9 or an approximate ground state generated via e.g.\nvariational quantum eigensolver [27] to a neural network.\nThe generated state has a variety of possible applica-\ntions. A straightforward application would be the clas-\nsification. To classify the data into Nc classes, we mea-\nsure certain \u2308log2 Nc\u2309 qubits of the output state (25).\nNote that in this case, we do not need to output a full\nvector like Eq. (25) and can exploit the fact that we\ncan output a state like PNc\nk=1 F(PN\nj=1 vkj\u03c8j) |k\u27e9. An-",
    "Note that in this case, we do not need to output a full\nvector like Eq. (25) and can exploit the fact that we\ncan output a state like PNc\nk=1 F(PN\nj=1 vkj\u03c8j) |k\u27e9. An-\nother possible application is to use the output state in\nEq. (25) for a generative model [28]. The purpose of\ngenerative models is to create a machine that can sample\nfrom a probability distribution that is close to the distri-\nbution of data. Since it has been shown that sampling\nfrom a certain family of quantum states is classically hard\n[29], it is a promising direction to explore the usefulness\nof quantum computers for this task. In contrast to the\nprevious works [30\u201332], our algorithm can provide non-\nlinearity and it may have better performance compared\nwith them. Finally, we mention that the transformation\ncan be considered as a quantum feature map [22, 23]\nthat takes a quantum data |\u03c8\u27e9 as an input and maps\nthe state nonlinearly to create a quantum feature vector\n|\u03a8(\u03c8)\u27e9 = PN\nk=1 F\n\u0010PN\nj=1 vkj\u03c8j\n\u0011",
    "can be considered as a quantum feature map [22, 23]\nthat takes a quantum data |\u03c8\u27e9 as an input and maps\nthe state nonlinearly to create a quantum feature vector\n|\u03a8(\u03c8)\u27e9 = PN\nk=1 F\n\u0010PN\nj=1 vkj\u03c8j\n\u0011\n|k\u27e9. The inner product\nof the feature vectors, \u27e8\u03a8(\u03c81)|\u03a8(\u03c82)\u27e9, can be exploited\nfor quantum kernel methods [22, 23], which constructs a\nmachine learning model based on the inner products of\ndata in a feature space. We can also perform quantum\ncircuit learning [21] by applying a trainable unitary to\n|\u03a8(\u03c8)\u27e9.\nIt is also possible to obtain the values of the N1(\u2264 N)\ndimensional nodes, i.e.,\nn\nF\n\u0010P\nj vkj\u03c8j\n\u0011oN1\nk=1\n, by using\namplitude estimation [16]. The amplitude estimation es-\nsentially allows us to estimate the absolute value |a| of\nan amplitude a in a quantum state |\u03d5\u27e9 = a |0\u27e9+ \u00b7\u00b7\u00b7 with\nan additive error \u03b2 by O(1/\u03b2) uses of a quantum circuit\nthat creates |\u03d5\u27e9. Note that a itself can also be estimated\nif we can construct quantum circuits that create a state\nin the form of 1+a\n2 |0\u27e9+\u00b7\u00b7\u00b7 and 1+ia",
    "that creates |\u03d5\u27e9. Note that a itself can also be estimated\nif we can construct quantum circuits that create a state\nin the form of 1+a\n2 |0\u27e9+\u00b7\u00b7\u00b7 and 1+ia\n2 |0\u27e9+\u00b7\u00b7\u00b7 . In this case,\nwe can separately estimate |1 + a|, |1 + ia| and |a| from\nwhich Re(a) and Im( a) can be reconstructed. Since we\ncan easily construct a quantum circuit that implements\nthe functions 1+F\n2 and 1+iF\n2 instead of F by QSVT, we\ncan estimate each of\nn\nF\n\u0010P\nj vkj\u03c8j\n\u0011oN1\nk=1\nwith an addi-\ntive error \u03b2 with O\n\u0000\u221aN1/\u03b2\n\u0001\nuses of the circuit in Fig.\n4. To estimate all of them, we need to repeat it for N1\ntimes and thus require O\n\u0010\nN3/2\n1 /\u03b2\n\u0011\nuses of the circuit.\nFinally, as a natural extension, we consider how to im-\nplement a multi-layer neural network. We first consider\nhow to achieve the two-layer neural network. More con-\ncretely, we wish to prepare a state in the form of,\nN2X\nl=1\nF\n\uf8ee\n\uf8f0\nN1X\nk=1\nv(2)\nlk F\n\uf8eb\n\uf8ed\nNX\nj=1\nv(1)\nkj \u03c8j\n\uf8f6\n\uf8f8\n\uf8f9\n\uf8fb|l\u27e9, (26)\nV (\u2113) = P\nk,j v(\u2113)\nkj |k\u27e9\u27e8j| are tranable unitaries connect-",
    "cretely, we wish to prepare a state in the form of,\nN2X\nl=1\nF\n\uf8ee\n\uf8f0\nN1X\nk=1\nv(2)\nlk F\n\uf8eb\n\uf8ed\nNX\nj=1\nv(1)\nkj \u03c8j\n\uf8f6\n\uf8f8\n\uf8f9\n\uf8fb|l\u27e9, (26)\nV (\u2113) = P\nk,j v(\u2113)\nkj |k\u27e9\u27e8j| are tranable unitaries connect-\ning the ( \u2113 \u2212 1)-th and \u2113-th layers, that is, we take in-\nput vector {\u03c8j} as zeroth layer. We assumed the \u2113-\nth layer has N\u2113 nodes. Let A1 be the quantum cir-\ncuit for a single-layer neural network, i.e., the circuit in\nFig. 4 with U = V (1)U\u03c8. It is easy to see that the\nstate of Eq. (26) can essentially be constructed by us-\ning\n\u0000\nI5 \u2297 V (2) \u2297 In+1\n\u0001\nA1 as the state preparation ora-\ncle in Theorem 5. Detailed analysis of this process is\npresented in Appendix D. \u2113-layer neural network can be\nachieved by repeating the above steps \u2113 \u2212 1 times. As\nshown in Appendix D, a quantum state which corre-\nsponds to an \u2113-layer neural network can be generated\nby \u02dcO\n\u0000\nd\u2113p\nN1N2 \u00b7\u00b7\u00b7 N\u2113\u22121\n\u0001\n.\nV. CONCLUSION\nWe have defined a task called NTCA considering how\nto apply nonlinear functions onto the amplitudes of",
    "sponds to an \u2113-layer neural network can be generated\nby \u02dcO\n\u0000\nd\u2113p\nN1N2 \u00b7\u00b7\u00b7 N\u2113\u22121\n\u0001\n.\nV. CONCLUSION\nWe have defined a task called NTCA considering how\nto apply nonlinear functions onto the amplitudes of\na quantum state. To this end, we introduced block-\nencoding of amplitudes , which encodes amplitudes of a\nquantum state on a block element of a unitary opera-\ntor by using the state preparation oracle. This allows\nus to treat complex amplitudes of a quantum state as7\nsingular values of a matrix encoded into a unitary op-\nerator and hence to apply QSVT for NTCA. Since the\nproposed mapping from a state preparation oracle to a\nblock-encoding unitary is very general, we expect that it\ncan be applied widely when we want to process a quan-\ntum state in such a way that cannot be achieved by a\nsimple unitary transformation. As a concrete example of\nsuch an application, we proposed to use our algorithm\nto implement neural networks on quantum computers,",
    "simple unitary transformation. As a concrete example of\nsuch an application, we proposed to use our algorithm\nto implement neural networks on quantum computers,\nwhere complex amplitudes are used as nodes for the neu-\nral networks and nonlinear transformations, which can-\nnot be realized by a unitary operation, are performed by\nthe proposed NTCA. From scaling analysis, our result\nimplies that there could be a complexity-theoretic ben-\nefit to use a quantum computer to process and perform\na nonlinear transformation on a high dimensional input\ndata, while it still relies on several assumptions such as\nthe state preparation oracle. It is an interesting open\nquestion whether the proposed nonlinear transformation\nor quantum neural network can provide an advantage in\nclassical machine learning tasks. We think that it is, at\nleast, inevitable to apply quantum machine learning for\nquantum data since a systematic nonlinear transforma-\ntion is essentially missing in quantum systems without",
    "least, inevitable to apply quantum machine learning for\nquantum data since a systematic nonlinear transforma-\ntion is essentially missing in quantum systems without\nthe proposed method.\nNote-added. The first preprint version of this\nmanuscript was released in July 2021. Since then, there\nhave been several further developments. A similar task\nwas considered in the parameterized quantum circuit set-\nting [33]. By using the importance-weighted method and\nfor functions like tanh( x), one can remove the depen-\ndency on the input dimension N [34]. Applications like\nquantum machine learning, state preparation, and max-\nimum finding have been investigated [34\u201337].\nACKNOWLEDGMENTS\nNG is supported by Hirose Foundation. KM is sup-\nported by JST PRESTO Grant No. JPMJPR2019 and\nJSPS KAKENHI Grant No. 20K22330. KF is sup-\nported by JSPS KAKENHI Grant No. 16H02211, JST\nERATO JPMJER1601, and JST CREST JPMJCR1673.\nThis work is supported by MEXT Quantum Leap Flag-",
    "JSPS KAKENHI Grant No. 20K22330. KF is sup-\nported by JSPS KAKENHI Grant No. 16H02211, JST\nERATO JPMJER1601, and JST CREST JPMJCR1673.\nThis work is supported by MEXT Quantum Leap Flag-\nship Program (MEXT QLEAP) Grant Number JP-\nMXS0118067394 and JPMXS0120319794. We also ac-\nknowledge support from JST COI-NEXT program.\nAppendix A: Details for Theorem 4\n1. Derivation of Eq. (8)\n1. Apply the oracle U on data qubits, the state will\nbe\n|k\u27e9ad\n\uf8eb\n\uf8ed\nNX\nj=1\ncj |0\u27e9\u2297a |j\u27e9\n\uf8f6\n\uf8f8\nda\n|0\u27e9B . (A1)\n2. Perform Hadamard gate on the B ancilla qubit and\ncontrolled-U gate with B as controlled qubits, we\nprepare the state\n|k\u27e9ad\n\u0012\u0000 NX\nj=1\ncj |j\u27e9\n\u0001\nda|0\u27e9B + |0\u27e9\u2297n\nda |1\u27e9B\n\u0013\n. (A2)\n3. Apply Toffoli gates with address qubits and B an-\ncilla qubit as controlled gates and Hadamard gate\non the B ancilla qubits, we have\n|k\u27e9ad |\u03a8k\u27e9da,B :=|k\u27e9\n2 ad\n\u0012\u0000 NX\nj=1\ncj |j\u27e9 + |k\u27e9\n\u0001\nda|0\u27e9B\n+\n\u0000 NX\nj=1\ncj |j\u27e9 \u2212 |k\u27e9\n\u0001\nda|1\u27e9B\n\u0013\n. (A3)\n2. Eigenvalues and eigenvectors ofG\nHere, we derive the eigenvalues and eigenvectors",
    "|k\u27e9ad |\u03a8k\u27e9da,B :=|k\u27e9\n2 ad\n\u0012\u0000 NX\nj=1\ncj |j\u27e9 + |k\u27e9\n\u0001\nda|0\u27e9B\n+\n\u0000 NX\nj=1\ncj |j\u27e9 \u2212 |k\u27e9\n\u0001\nda|1\u27e9B\n\u0013\n. (A3)\n2. Eigenvalues and eigenvectors ofG\nHere, we derive the eigenvalues and eigenvectors\nof G defined in Eq. 9. It can be seen that G\nhas invariant two-dimensional subspaces spanned by\n{|k\u27e9|\u03a8k0\u27e9, |k\u27e9|\u03a8k1\u27e9}N\nk=1 for each k \u2208 {1, ..., N}. Let\nZB, W S0W\u2020, G be the operations ZB, W S0W\u2020 and G\nacting only on these subspaces.\nThe matrix representation of ZB, W S0W\u2020 can be writ-\nten as,\nZB =|k\u27e9|\u03a8k0\u27e9\u27e8\u03a8k0|\u27e8k| \u2212 |k\u27e9|\u03a8k1\u27e9\u27e8\u03a8k1|\u27e8k| (A4)\nW S0W\u2020 =(1 \u2212 2\u03b12\nk)|k\u27e9|\u03a8k0\u27e9\u27e8\u03a8k0|\u27e8k|\n+ (1 \u2212 2\u03b22\nk)|k\u27e9|\u03a8k1\u27e9\u27e8\u03a8k1|\u27e8k|\n\u2212 2\u03b1k\u03b2k (|k\u27e9|\u03a8k1\u27e9\u27e8\u03a8k0|\u27e8k| + |k\u27e9|\u03a8k0\u27e9\u27e8\u03a8k1|\u27e8k|) .\n(A5)\nThus, we have,\nG =W S0W\u2020ZB (A6)\n=(1 \u2212 2\u03b12\nk)|k\u27e9|\u03a8k0\u27e9\u27e8\u03a8k0|\u27e8k|\n\u2212 (1 \u2212 2\u03b22\nk)|k\u27e9|\u03a8k1\u27e9\u27e8\u03a8k1|\u27e8k|\n\u2212 2\u03b1k\u03b2k(|k\u27e9|\u03a8k1\u27e9\u27e8\u03a8k0|\u27e8k| \u2212 |k\u27e9|\u03a8k0\u27e9\u27e8\u03a8k1|\u27e8k|).\n(A7)8\nTherefore, eigenvectors of G can be written as\n|k\u27e9ad |\u03a8k\u00b1\u27e9da,B = 1\u221a\n2 |k\u27e9ad (|\u03a8k0\u27e9 \u00b1i |\u03a8k1\u27e9)da,B, (A8)\nwith the corresponding eigenvalue \u2212xk \u00b1 i\np\n1 \u2212 x2\nk. G\nhas the same eigenvalues and eigenvectors.",
    "|k\u27e9ad |\u03a8k\u00b1\u27e9da,B = 1\u221a\n2 |k\u27e9ad (|\u03a8k0\u27e9 \u00b1i |\u03a8k1\u27e9)da,B, (A8)\nwith the corresponding eigenvalue \u2212xk \u00b1 i\np\n1 \u2212 x2\nk. G\nhas the same eigenvalues and eigenvectors.\n3. One- and two-qubit gate counts\nTo construct \u02dcU as in Theorem 4, we use controlled- G\nand controlled-G\u2020 one time, which consists of controlled-\nH, controlled- Z, Toffoli gates on four qubits, and\ncontrolled-S0 gates. Decomposition of Toffoli gates is\ndescribed in [38]. Notice that here we use Toffoli gates\nO(n) times. The (controlled) conditional phase shift gate\nS0 = In+2 \u22122|0\u27e9\u27e80| on n qubits can be performed with a\nToffoli gate on ( n + 2) qubits and two Hadamard gates.\nAs described in [39], Toffoli gate on ( n + 2) qubits can\nbe performed with O(n) gates with an additional an-\ncilla qubit. Therefore, in total, we use controlled- U and\ncontrolled-U\u2020 four times and O(n) one- and two-qubit\ngates for Theorem 4.\nAppendix B: Detailed error analysis for Theorem 5\nNote that P is a (1, 4, \u03f5/(16\u03b3))-block-encoding of a ma-",
    "controlled-U\u2020 four times and O(n) one- and two-qubit\ngates for Theorem 4.\nAppendix B: Detailed error analysis for Theorem 5\nNote that P is a (1, 4, \u03f5/(16\u03b3))-block-encoding of a ma-\ntrix whose eigenvalues are P\u2032(xk)/(4\u03b3). For all xk \u2208\n[\u22121, 1], we have\n|P\u2032(xk)/(4\u03b3) \u2212 P\u2032\u2032(xk)| \u2264\u03b5/(16\u03b3N ), (B1)\nwhere P\u2032\u2032(xk) denotes the exact value achieved by\nLemma 3. By assumption, we have |P(xk) \u2212 P\u2032(xk)| \u2264\n\u03b5/(4N). Therefore,\n|P(xk) \u2212 4\u03b3P \u2032\u2032(xk)|\n\u2264|P(xk) \u2212 P\u2032(xk)| + |P\u2032(xk) \u2212 4\u03b3P \u2032\u2032(xk)|\n\u2264|P(xk) \u2212 P\u2032(xk)| + 4\u03b3|P\u2032(xk)/(4\u03b3) \u2212 P\u2032\u2032(xk)| \u2264\u03b5\n2N ,\n(B2)\nwhere the inequalities comes from triangle inequality.\nThe same discussion applies for the imaginary part, i.e.,\n|Q(yk)\u22124\u03b3Q\u2032\u2032(yk)| \u2264\u03b5/(2N) for all yk \u2208 [\u22121, 1]. Finally,\nfor all xk, yk \u2208 [\u22121, 1] we have\n|4\u03b3P \u2032\u2032(xk) + 4\u03b3Q\u2032\u2032(yk) \u2212 P(xk) \u2212 Q(yk)| \u2264\u03b5\nN , (B3)\nsatisfying the error bound condition for NTCA.\nAppendix C: Polynomial approximation of tanh\nHere, we show that P(x) = tanh( x) can be approxi-\nmated to an precision \u03b5 with a degree d = O(log(1/\u03b5))",
    "satisfying the error bound condition for NTCA.\nAppendix C: Polynomial approximation of tanh\nHere, we show that P(x) = tanh( x) can be approxi-\nmated to an precision \u03b5 with a degree d = O(log(1/\u03b5))\npolynomial P\u2032\nd(x) in the sense that |P\u2032\nd(x)\u2212tanh(x)| \u2264\u03b5.\nIt suffices to use the simple Taylor series. By Taylor ex-\npansion,\ntanh(x) =\n\u221eX\nn=1\n(\u22121)n\u22121 22n(22n \u2212 1)B2n\n(2n)! x2n\u22121, (C1)\nwhere B2n is the Bernoulli number. We take,\nP\u2032\nd(x) =\ndX\nn=1\n(\u22121)n\u22121 22n(22n \u2212 1)B2n\n(2n)! x2n\u22121. (C2)\nThen, the error can be written as,\n|P\u2032\nd(x) \u2212 tanh(x)| =\n\u221eX\nn=d+1\n(\u22121)n\u22121 22n(22n \u2212 1)B2n\n(2n)! x2n\u22121.\n(C3)\nAs mentioned in Ref. [40], we have\n|B2n| < 5\u221a\u03c0n\n\u0010 n\n\u03c0e\n\u00112n\n. (C4)\nAlso, since (n/e)n \u2264 n!, we have\n22n(22n \u2212 1)B2n\n(2n)! < 5\u221a\u03c0n\n\u00124 n\n\u03c0e\n2n\ne\n\u00132n\n= 5\u221a\u03c0n\n\u00122\n\u03c0\n\u00132n\n. (C5)\nFurther, since\n\u221a\nd + 1 \u2264 (\u03c0/2)d+1 for d \u2265 0, we have\n5\np\n\u03c0(d + 1)\n\u00122\n\u03c0\n\u00132d+2\n\u2264 5\u221a\u03c0\n\u00122\n\u03c0\n\u0013d+1\n. (C6)\nTherefore, the error in Eq. (C3) can be bounded by\n\u221eX\nn=d+1\n(\u22121)n\u22121 22n(22n \u2212 1)B2n\n(2n)! x2n\u22121\n<\n\u221eX\nn=d+1\n22n(22n \u2212 1)B2n\n(2n)! x2n\u22121\n\u2264",
    "5\np\n\u03c0(d + 1)\n\u00122\n\u03c0\n\u00132d+2\n\u2264 5\u221a\u03c0\n\u00122\n\u03c0\n\u0013d+1\n. (C6)\nTherefore, the error in Eq. (C3) can be bounded by\n\u221eX\nn=d+1\n(\u22121)n\u22121 22n(22n \u2212 1)B2n\n(2n)! x2n\u22121\n<\n\u221eX\nn=d+1\n22n(22n \u2212 1)B2n\n(2n)! x2n\u22121\n\u2264\n\u221eX\nn=d+1\n5\u221a\u03c0\n\u00122\n\u03c0\n\u0013d+1\n= 5\u221a\u03c0\n1 \u2212 (2/\u03c0)\n\u00122\n\u03c0\n\u0013d+1\n. (C7)\nIt follows that the error bound of \u03b5 can be achieved by\nsetting d = O (log (1/\u03b5)).\nAppendix D: Generalization to multi-layer neural\nnetwork\nWe first consider how to perform a two-layer quan-\ntum neural network. For simplicity, we assume9\n|P(x)|, |Q(x)| \u22641 for all x \u2208 [\u22121, 1] so that \u03b3 = 1. We\nalso assume P(x) and Q(x) can exactly be expressed by\na d-degree polynomial to avoid a complicated discussion\nabout errors. Let A1 be the quantum circuit that outputs\nthe state\n1\n8\u221aN1\nN1X\nk=1\nF\n\uf8eb\n\uf8ed\nNX\nj=1\nv(1)\nkj \u03c8j\n\uf8f6\n\uf8f8|0\u27e9\u22975 |k\u27e9ad |0\u27e9\u2297n+1\nda,B + \u00b7\u00b7\u00b7 .\n(D1)\nAlso, let \u02dcA1 :=\n\u0000\nI5 \u2297 V (2) \u2297 In+1\n\u0001\nA1. Then,\n\u02dcA1 |0\u27e9\u22972n+6 =\n1\n8\u221aN1\nN2X\nl=1\n\uf8ee\n\uf8f0\nN1X\nk=1\nv(2)\nlk F\n\uf8eb\n\uf8ed\nNX\nj=1\nv(1)\nkj \u03c8j\n\uf8f6\n\uf8f8\n\uf8f9\n\uf8fb|0\u27e9\u22975 |l\u27e9ad |0\u27e9\u2297n+1\nda,B + \u00b7\u00b7\u00b7 .\n(D2)",
    "da,B + \u00b7\u00b7\u00b7 .\n(D1)\nAlso, let \u02dcA1 :=\n\u0000\nI5 \u2297 V (2) \u2297 In+1\n\u0001\nA1. Then,\n\u02dcA1 |0\u27e9\u22972n+6 =\n1\n8\u221aN1\nN2X\nl=1\n\uf8ee\n\uf8f0\nN1X\nk=1\nv(2)\nlk F\n\uf8eb\n\uf8ed\nNX\nj=1\nv(1)\nkj \u03c8j\n\uf8f6\n\uf8f8\n\uf8f9\n\uf8fb|0\u27e9\u22975 |l\u27e9ad |0\u27e9\u2297n+1\nda,B + \u00b7\u00b7\u00b7 .\n(D2)\n\u02dcA1 can be considered as the state preparation oracle for\nTheorem 5 to achieve the two-layer neural network. How-\never, before doing so, we remove the coefficient 1/(8\u221aN1)\nby uniform singular value amplification [4, 12]. To do\nso, first note that, by Theorem 4, we can construct\na block-encoding \u02dcG(2) of a matrix \u22121\n2\n\u0000\nG(2) + (G(2))\u2020\u0001\nwhose eigenvalues are\n\uf8f1\n\uf8f2\n\uf8f3\n1\n8\u221aN1\nN1X\nk=1\nv(2)\nlk F\n\uf8eb\n\uf8ed\nNX\nj=1\nv(1)\nkj \u03c8j\n\uf8f6\n\uf8f8\n\uf8fc\n\uf8fd\n\uf8fe\nN1\nk=1\n. (D3)\nThe coefficient 1 /(8\u221aN1) from these eigenvalues can be\nremoved by using uniform singular value amplification\nwhich uses \u02dcA1 and \u02dcA\u2020\n1 \u02dcO\n\u0000\u221aN1\n\u0001\ntimes. Let \u02dcA\u2032\n1 be the\ncircuit constructed by the above procedure, i.e.,\n\u02dcA\u2032\n1 |0\u27e9\u22972n+6\n=\nN2X\nl=1\n\uf8ee\n\uf8f0\nN1X\nk=1\nv(2)\nlk F\n\uf8eb\n\uf8ed\nNX\nj=1\nv(1)\nkj \u03c8j\n\uf8f6\n\uf8f8\n\uf8f9\n\uf8fb|0\u27e9\u22975 |l\u27e9ad |0\u27e9\u2297n+1\nda,B + \u00b7\u00b7\u00b7 .\n(D4)\nAfter this step, we use Theorem 5 on \u02dcA\u2032",
    "\u02dcA\u2032\n1 |0\u27e9\u22972n+6\n=\nN2X\nl=1\n\uf8ee\n\uf8f0\nN1X\nk=1\nv(2)\nlk F\n\uf8eb\n\uf8ed\nNX\nj=1\nv(1)\nkj \u03c8j\n\uf8f6\n\uf8f8\n\uf8f9\n\uf8fb|0\u27e9\u22975 |l\u27e9ad |0\u27e9\u2297n+1\nda,B + \u00b7\u00b7\u00b7 .\n(D4)\nAfter this step, we use Theorem 5 on \u02dcA\u2032\n1 to achieve the\nstate\n1\n8\u221aN2\nN2X\nl=1\nF\n\uf8ee\n\uf8f0\nN1X\nk=1\nv(2)\nlk F\n\uf8eb\n\uf8ed\nNX\nj=1\nv(1)\nkj \u03c8j\n\uf8f6\n\uf8f8\n\uf8f9\n\uf8fb|0\u27e9\u22975 |l\u27e9ad |0\u27e9\u2297n+1\nda,B + \u00b7\u00b7\u00b7 .\n(D5)\nCounting the U\u03c8 operations used in this whole procedure,\nthis state can be prepared with \u02dcO\n\u0000\nd2\u221aN1\n\u0001\nuses of U\u03c8.\nAn \u2113-layer neural network can be achieved by re-\npeating the above procedure \u2113 \u2212 1 times, and it uses\n\u02dcO\n\u0000\nd\u2113p\nN1N2 \u00b7\u00b7\u00b7 N\u2113\u22121\n\u0001\ntimes of U\u03c8. If we want to fur-\nther obtain the values of each amplitude with an additive\nerror \u03b2, we perform the amplitude estimation on the re-\nsulting state. This would require repeating the whole\ncircuit for O\n\u0010\nN3/2\n\u2113 /\u03b2\n\u0011\ntimes, and the total number of\nU\u03c8 is calculated to be \u02dcO\n\u0000\nd\u2113N\u2113\n\u221aN1N2 \u00b7\u00b7\u00b7 N\u2113/\u03b2\n\u0001\n.\n[1] D. S. Abrams and S. Lloyd, Phys. Rev. Lett. 81, 3992\n(1998).\n[2] A. W. Harrow, A. Hassidim, and S. Lloyd, Phys. Rev.\nLett. 103, 150502 (2009).",
    "U\u03c8 is calculated to be \u02dcO\n\u0000\nd\u2113N\u2113\n\u221aN1N2 \u00b7\u00b7\u00b7 N\u2113/\u03b2\n\u0001\n.\n[1] D. S. Abrams and S. Lloyd, Phys. Rev. Lett. 81, 3992\n(1998).\n[2] A. W. Harrow, A. Hassidim, and S. Lloyd, Phys. Rev.\nLett. 103, 150502 (2009).\n[3] G. H. Low and I. L. Chuang, Phys. Rev. Lett. 118,\n010501 (2017).\n[4] A. Gily\u00b4 en, Y. Su, G. H. Low, and N. Wiebe, in Pro-\nceedings of the 51st Annual ACM SIGACT Symposium\non Theory of Computing, STOC 2019 (Association for\nComputing Machinery, New York, NY, USA, 2019) p.\n193\u2013204.\n[5] J. M. Martyn, Z. M. Rossi, A. K. Tan, and I. L.\nChuang, A grand unification of quantum algorithms\n(2021), arXiv:2105.02859 [quant-ph].\n[6] A. M. Childs and N. Wiebe, Quantum Info. Comput. 12,\n901\u2013924 (2012).\n[7] D. W. Berry, A. M. Childs, R. Cleve, R. Kothari, and\nR. D. Somma, Phys. Rev. Lett. 114, 090502 (2015).\n[8] G. H. Low and I. L. Chuang, Quantum 3, 163 (2019).\n[9] A. M. Childs, R. Kothari, and R. D. Somma, SIAM Jour-\nnal on Computing 46, 1920\u20131950 (2017).",
    "[8] G. H. Low and I. L. Chuang, Quantum 3, 163 (2019).\n[9] A. M. Childs, R. Kothari, and R. D. Somma, SIAM Jour-\nnal on Computing 46, 1920\u20131950 (2017).\n[10] D. W. Berry, A. M. Childs, and R. Kothari, 2015 IEEE\n56th Annual Symposium on Foundations of Computer\nScience 10.1109/focs.2015.54 (2015).\n[11] T. J. Yoder, G. H. Low, and I. L. Chuang, Phys. Rev.\nLett. 113, 210501 (2014).\n[12] G. H. Low and I. L. Chuang, Hamiltonian simulation by\nuniform spectral amplification (2017), arXiv:1707.05391\n[quant-ph].\n[13] S. Chakraborty, A. Gily\u00b4 en, and S. Jeffery, in46th Inter-\nnational Colloquium on Automata, Languages, and Pro-\ngramming (ICALP 2019), Leibniz International Proceed-\nings in Informatics (LIPIcs), Vol. 132, edited by C. Baier,\nI. Chatzigiannakis, P. Flocchini, and S. Leonardi (Schloss\nDagstuhl\u2013Leibniz-Zentrum fuer Informatik, Dagstuhl,\nGermany, 2019) pp. 33:1\u201333:14.\n[14] K. Mitarai, M. Kitagawa, and K. Fujii, Phys. Rev. A 99,\n012301 (2019).",
    "Dagstuhl\u2013Leibniz-Zentrum fuer Informatik, Dagstuhl,\nGermany, 2019) pp. 33:1\u201333:14.\n[14] K. Mitarai, M. Kitagawa, and K. Fujii, Phys. Rev. A 99,\n012301 (2019).\n[15] A. Pinkus, Journal of Approximation Theory 107, 1\n(2000).\n[16] G. Brassard, P. Hoyer, M. Mosca, and A. Tapp,\narXiv e-prints , quant-ph/0005055 (2000), arXiv:quant-\nph/0005055 [quant-ph].\n[17] R. Cleve, A. Ekert, C. Macchiavello, and M. Mosca, Pro-\nceedings of the Royal Society of London. Series A: Mathe-\nmatical, Physical and Engineering Sciences 454, 339\u2013354\n(1998).\n[18] M. Schuld and F. Petruccione, Supervised Learning with\nQuantum Computers(Springer International Publishing,\n2018).\n[19] V. Giovannetti, S. Lloyd, and L. Maccone, Phys. Rev.\nLett. 100, 160501 (2008).10\n[20] I. Kerenidis and A. Prakash, Quantum recommendation\nsystems (2016), arXiv:1603.08675 [quant-ph].\n[21] K. Mitarai, M. Negoro, M. Kitagawa, and K. Fujii, Phys.\nRev. A 98, 032309 (2018).\n[22] M. Schuld and N. Killoran, Phys. Rev. Lett. 122, 040504\n(2019).",
    "[21] K. Mitarai, M. Negoro, M. Kitagawa, and K. Fujii, Phys.\nRev. A 98, 032309 (2018).\n[22] M. Schuld and N. Killoran, Phys. Rev. Lett. 122, 040504\n(2019).\n[23] V. Havl\u00b4 \u0131\u02c7 cek, A. D. C\u00b4 orcoles, K. Temme, A. W. Harrow,\nA. Kandala, J. M. Chow, and J. M. Gambetta, Nature\n567, 209\u2013212 (2019).\n[24] E. Farhi and H. Neven, Classification with quan-\ntum neural networks on near term processors (2018),\narXiv:1802.06002 [quant-ph].\n[25] J. R. Glick, T. P. Gujarati, A. D. Corcoles, Y. Kim,\nA. Kandala, J. M. Gambetta, and K. Temme, Covariant\nquantum kernels for data with group structure (2021),\narXiv:2105.03406 [quant-ph].\n[26] T. Kusumoto, K. Mitarai, K. Fujii, M. Kitagawa, and\nM. Negoro, npj Quantum Information 7, 94 (2021).\n[27] A. Peruzzo, J. McClean, P. Shadbolt, M.-H. Yung, X.-Q.\nZhou, P. J. Love, A. Aspuru-Guzik, and J. L. O\u2019brien,\nNature communications 5, 4213 (2014).\n[28] A. Ng and M. Jordan, in Advances in Neural Informa-\ntion Processing Systems, Vol. 14, edited by T. Dietterich,",
    "Nature communications 5, 4213 (2014).\n[28] A. Ng and M. Jordan, in Advances in Neural Informa-\ntion Processing Systems, Vol. 14, edited by T. Dietterich,\nS. Becker, and Z. Ghahramani (MIT Press, 2002).\n[29] A. P. Lund, M. J. Bremner, and T. C. Ralph, npj Quan-\ntum Information 3, 15 (2017).\n[30] P.-L. Dallaire-Demers and N. Killoran, Phys. Rev. A 98,\n012324 (2018).\n[31] J. Romero and A. Aspuru-Guzik, Variational quan-\ntum generators: Generative adversarial quantum ma-\nchine learning for continuous distributions (2019),\narXiv:1901.00848 [quant-ph].\n[32] C. Zoufal, A. Lucchi, and S. Woerner, npj Quantum In-\nformation 5, 103 (2019).\n[33] Z. Holmes, N. J. Coble, A. T. Sornborger, and Y. b. u.\nSuba\u00b8 s \u0131, Phys. Rev. Res.5, 013105 (2023).\n[34] A. G. Rattew and P. Rebentrost, Non-linear trans-\nformations of quantum amplitudes: Exponential im-\nprovement, generalization, and applications (2023),\narXiv:2309.09839 [quant-ph].\n[35] J. Gonzalez-Conde, T. W. Watts, P. Rodriguez-Grasa,",
    "formations of quantum amplitudes: Exponential im-\nprovement, generalization, and applications (2023),\narXiv:2309.09839 [quant-ph].\n[35] J. Gonzalez-Conde, T. W. Watts, P. Rodriguez-Grasa,\nand M. Sanz, Quantum 8, 1297 (2024).\n[36] N. Guo, Z. Yu, A. Agrawal, and P. Rebentrost, Quantum\nlinear algebra is all you need for transformer architectures\n(2024), arXiv:2402.16714 [quant-ph].\n[37] W. Roga, B. Chevalier, and M. Takeoka, Fully quantum\nclassifier (2023), arXiv:2307.03396 [quant-ph].\n[38] M. A. Nielsen and I. L. Chuang, Quantum Computation\nand Quantum Information: 10th Anniversary Edition\n(Cambridge University Press, 2010).\n[39] Y. He, M.-X. Luo, E. Zhang, H.-K. Wang, and X.-F.\nWang, International Journal of Theoretical Physics 56,\n2350 (2017).\n[40] D. J. Leeming, Journal of Approximation Theory 58, 124\n(1989)."
  ],
  "summary": "This document, \"Nonlinear transformation of complex amplitudes via quantum singular value transformation\" by Guo, Mitarai, and Fujii, presents a novel quantum algorithm for applying nonlinear functions directly to the amplitudes of a quantum state. This task, which the authors name Nonlinear Transformation of Complex Amplitudes (NTCA), addresses a fundamental challenge in quantum computing: the inherent linearity of quantum mechanics, which makes implementing nonlinear operations\u2014essential for applications like neural networks and solving nonlinear differential equations\u2014non-trivial.\n\n### **Main Idea: The NTCA Task and Core Strategy**\n\nThe central problem the paper tackles is how to transform a given quantum state, prepared by an oracle `U` such that `U|0\u27e9 = \u03a3 c_k |k\u27e9`, into a new state proportional to `\u03a3 (P(x_k) + Q(y_k)) |k\u27e9`. Here, `c_k = x_k + i*y_k` are the complex amplitudes of the initial state, and `P` and `Q` are arbitrary nonlinear functions.\n\nThe authors' core strategy is to leverage the power of the Quantum Singular Value Transformation (QSVT) algorithm. QSVT is a powerful quantum subroutine that can apply a polynomial function to the singular values of a matrix. However, QSVT operates on matrices, not directly on the amplitudes of a quantum state. The primary innovation of this work is to devise a method to represent the real (`x_k`) and imaginary (`y_k`) parts of the amplitudes as the singular values of a matrix that can be efficiently constructed. This crucial step, which they term **\"block-encoding of amplitudes,\"** bridges the gap between the state's amplitudes and the input required by QSVT.\n\n### **Key Technical Innovation: Block-Encoding of Amplitudes**\n\nThe technical heart of the paper is the construction of a block-encoding for the amplitudes. A block-encoding of a matrix `A` is a larger unitary `U_A` such that `A` is embedded in the top-left block of `U_A`. Once such a `U_A` is found, QSVT can be applied.\n\nThe authors detail a procedure (Theorem 4) to construct a unitary `G\u0303` that serves as a block-encoding for a matrix whose eigenvalues are precisely the real parts of the amplitudes, `{x_k}`. The construction proceeds as follows:\n\n1.  **Constructing an initial unitary `W`:** Using the state preparation oracle `U` and its adjoint `U\u2020`, along with controlled versions, they build a unitary operator `W`. This operator cleverly maps a basis state `|k\u27e9` to a superposition that contains the full state `\u03a3 c_j |j\u27e9`.\n\n2.  **Encoding amplitudes into phases:** They then construct a second unitary, `G = W S\u2080 W\u2020 Z_B`, where `S\u2080` is a conditional phase gate. They show that this operator `G` has eigenvectors whose corresponding eigenvalues are `e^(\u00b1i arccos(x_k))`. This is a critical step: the real part of the amplitude, `x_k`, is now encoded in the phase of an eigenvalue of `G`.\n\n3.  **Extracting amplitudes as eigenvalues:** To convert the phase-encoded value `arccos(x_k)` into the desired value `x_k`, they use a standard technique. They construct a final, larger unitary `G\u0303` using `G` and controlled-`G` operations. This new unitary `G\u0303` is a block-encoding of the Hermitian matrix `(G + G\u2020)/2`. The eigenvalues of this matrix are `cos(arccos(x_k)) = x_k`.\n\nThis procedure successfully creates a block-encoding of a matrix `\u03a3 x_k |\u03c6_k\u27e9\u27e8\u03c6_k|`, where the eigenvalues are the real parts of the original amplitudes. The authors state that an analogous procedure can be used to construct a separate unitary, `G\u0303'`, which block-encodes the imaginary parts, `{y_k}`.\n\n### **The Complete NTCA Algorithm and its Performance**\n\nWith the block-encodings for `{x_k}` and `{y_k}` established, the full NTCA algorithm proceeds as follows:\n\n1.  **Polynomial Approximation:** The target nonlinear functions `P` and `Q` are approximated by polynomials `P'` and `Q'` of degree `d`. The accuracy of this approximation determines the overall precision of the algorithm.\n\n2.  **Applying QSVT:** The QSVT algorithm is applied to the block-encoding `G\u0303` using the polynomial `P'`. This transforms the block-encoded matrix `\u03a3 x_k |\u03c6_k\u27e9\u27e8\u03c6_k|` into `\u03a3 P'(x_k) |\u03c6_k\u27e9\u27e8\u03c6_k|`. The same is done for `G\u0303'` and `Q'`.\n\n3.  **State Preparation:** These transformed block-encodings are then used in a final circuit to prepare the desired output state, which is proportional to `\u03a3 (P'(x_k) + Q'(y_k)) |k\u27e9`. This step is probabilistic and relies on post-selection by measuring ancilla qubits.\n\nThe authors analyze the complexity of this algorithm, which is one of the key findings of the paper. The number of times the state preparation oracle `U` (and its controlled versions) must be called is approximately:\n`O(d * sqrt(N / \u03a3|P'(x_k) + Q'(y_k)|\u00b2))`\nwhere `N` is the dimension of the state vector and `d` is the degree of the polynomial approximation.\n\nThis result highlights two major advantages:\n*   **Quantum Speedup in Dimension:** The complexity scales with `sqrt(N)`, offering a potential quadratic speedup over any classical algorithm that would need to read or process all `N` amplitudes.\n*   **Exponential Speedup in Precision:** The paper claims an exponential speedup in terms of the desired precision `\u03b5` compared to previous work. This is because the degree `d` of the polynomial required to achieve precision `\u03b5` typically grows logarithmically with `1/\u03b5`, a feature inherited from QSVT.\n\n### **Applications and Significance**\n\nThe primary application discussed is in **quantum machine learning (QML)**. Many QML algorithms encode classical data into the amplitudes of a quantum state. A major limitation has been the difficulty of applying nonlinear functions, such as the activation functions (e.g., ReLU, sigmoid) used in classical neural networks.\n\nThe NTCA algorithm provides a direct and efficient method to implement these nonlinear activation functions on quantum data. This could enable the construction of more complex and powerful quantum neural networks, where layers of linear transformations (standard in quantum circuits) are interspersed with nonlinear activation layers implemented via NTCA. This work opens a promising avenue for introducing sophisticated, classical-inspired nonlinearity into quantum states, a capability that has been largely missing and could be crucial for achieving a quantum advantage in machine learning and other domains.",
  "created_at": "2025-08-31T23:05:55.327440"
}